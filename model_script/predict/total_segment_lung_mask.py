"""
Generate binary lung masks using TotalSegmentator and save them for later prediction masking.

Example:
    python -m model_script.predict.total_segment_lung_mask \
        --images_dir ./data/images \
        --output_dir ./data/lung_mask 
"""

from __future__ import annotations

import argparse
import shutil
from pathlib import Path
from tempfile import TemporaryDirectory
from typing import Iterable, List, Set, Tuple

import nibabel as nib
import numpy as np
from totalsegmentator.python_api import totalsegmentator


LUNG_LOBES: List[str] = [
    "lung_upper_lobe_left",
    "lung_lower_lobe_left",
    "lung_upper_lobe_right",
    "lung_middle_lobe_right",
    "lung_lower_lobe_right",
]


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Create lung masks with TotalSegmentator for all CT volumes in a folder.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "--images_dir",
        type=Path,
        default=Path("data/images"),
        help="Directory containing input CT volumes (NIfTI).",
    )
    parser.add_argument(
        "--image_glob",
        type=str,
        default="image_*.nii.gz",
        help="Glob pattern to select CT files inside images_dir.",
    )
    parser.add_argument(
        "--id_list",
        type=Path,
        default=None,
        help="Optional text file with image ids to process (one per line, with or without 'image_' prefix).",
    )
    parser.add_argument(
        "--output_dir",
        type=Path,
        default=Path("data/lung_mask"),
        help="Where to store the resulting binary masks.",
    )
    parser.add_argument(
        "--overwrite",
        action="store_true",
        help="Overwrite masks that already exist.",
    )
    parser.add_argument(
        "--keep_intermediate",
        action="store_true",
        help="Keep per-lobe masks generated by TotalSegmentator next to the final mask (for debugging).",
    )
    return parser.parse_args()


def load_id_whitelist(list_path: Path | None) -> Set[str] | None:
    if list_path is None:
        return None
    ids: Set[str] = set()
    with open(list_path, "r") as f:
        for line in f:
            entry = line.strip()
            if entry:
                ids.add(entry if entry.startswith("image_") else f"image_{entry}")
    return ids


def collect_images(images_dir: Path, glob_pat: str, whitelist: Set[str] | None) -> Iterable[Tuple[str, Path]]:
    for img_path in sorted(images_dir.glob(glob_pat)):
        case_id = img_path.name
        if case_id.endswith(".nii.gz"):
            case_id = case_id[:-7]
        elif case_id.endswith(".nii"):
            case_id = case_id[:-4]
        if whitelist is not None and case_id not in whitelist:
            continue
        yield case_id, img_path


def mask_filename(case_id: str) -> str:
    suffix = case_id[len("image_") :] if case_id.startswith("image_") else case_id
    return f"lung_mask_{suffix}.nii.gz"


def combine_lobes(lobe_dir: Path) -> Tuple[np.ndarray, np.ndarray, nib.Nifti1Header]:
    combined: np.ndarray | None = None
    affine: np.ndarray | None = None
    header: nib.Nifti1Header | None = None
    missing: List[str] = []

    for roi in LUNG_LOBES:
        roi_file = lobe_dir / f"{roi}.nii.gz"
        if not roi_file.exists():
            roi_file = lobe_dir / f"{roi}.nii"
        if not roi_file.exists():
            missing.append(roi)
            continue

        roi_img = nib.load(str(roi_file))
        roi_data = roi_img.get_fdata()
        if combined is None:
            combined = np.zeros_like(roi_data, dtype=np.uint8)
            affine = roi_img.affine
            header = roi_img.header.copy()
            header.set_data_dtype(np.uint8)
        combined |= (roi_data > 0).astype(np.uint8)

    if combined is None or affine is None or header is None:
        raise RuntimeError(
            "TotalSegmentator did not produce any lung lobe masks. Missing: "
            + ", ".join(missing) if missing else "No lobe outputs found."
        )

    if missing:
        print(f"Warning: missing lobe outputs {missing}, continuing with available ones.")
    return combined, affine, header


def save_mask(mask: np.ndarray, affine: np.ndarray, header: nib.Nifti1Header, dest: Path) -> None:
    dest.parent.mkdir(parents=True, exist_ok=True)
    img = nib.Nifti1Image(mask.astype(np.uint8, copy=False), affine, header)
    nib.save(img, str(dest))


def process_image(
    case_id: str,
    image_path: Path,
    output_dir: Path,
    *,
    device: str,
    overwrite: bool,
    keep_intermediate: bool,
) -> None:
    out_path = output_dir / mask_filename(case_id)
    if out_path.exists() and not overwrite:
        print(f"[skip] {case_id} (mask already exists)")
        return

    with TemporaryDirectory() as tmp:
        tmp_dir = Path(tmp)
        totalsegmentator(
            str(image_path),
            str(tmp_dir),
            roi_subset=LUNG_LOBES,
            device=device,
            quiet=True,
        )
        mask_np, affine, header = combine_lobes(tmp_dir)
        mask_np = (mask_np > 0).astype(np.uint8, copy=False)  # ensure strict 0/1 output
        save_mask(mask_np, affine, header, out_path)

        if keep_intermediate:
            lobes_dir = out_path.parent / f"{case_id}_lobes"
            lobes_dir.mkdir(parents=True, exist_ok=True)
            for file in tmp_dir.iterdir():
                shutil.copy(file, lobes_dir / file.name)

    print(f"[ok]   {case_id} -> {out_path}")


def main() -> None:
    args = parse_args()
    import torch
    if not torch.cuda.is_available():
        raise SystemExit("CUDA device not available, but this script is configured to always use CUDA.")

    whitelist = load_id_whitelist(args.id_list)
    device = "gpu"

    images = list(collect_images(args.images_dir, args.image_glob, whitelist))
    if not images:
        raise SystemExit(f"No images found in {args.images_dir} matching '{args.image_glob}'.")

    args.output_dir.mkdir(parents=True, exist_ok=True)

    for case_id, img_path in images:
        process_image(
            case_id,
            img_path,
            args.output_dir,
            device=device,
            overwrite=args.overwrite,
            keep_intermediate=args.keep_intermediate,
        )

    print(f"Done. Masks written to {args.output_dir}")


if __name__ == "__main__":
    main()
